# 객체지향(1970~현재)
- 절차지향(순서대로 명령어를 입력해서 실행)이 주를 이룸.
- 유지보수, 개발기간에서 비 효율이 발생하면서 효과적인 개발 방식을 채택함.
- 추상화, 상속, 은닉, 재사용, 인터페이스등 객체지향의 특성으로 개발을 시작.

# 객체지향
-현실에 존재하는 사물을 모델링하여 행위와 속성을 정의
-절차적이 아닌 객체가 중심이 되어 실제 사물이 동작하는 방식으로 설계
  · 사물 - 객체
  · 사물의 행위 - Method
  · 사물의 속성 - 변수
-실제 사물중심 설계라 절차지향보다 더 편리하게 설계 가능.

# JAVA
-C++과 유사한 언어의 구문을 채택
-어떠한 운영체제에서도 자바 가상 머신만 있으면, 독립적으로 실행.(플랫폼 호환성 제공)

​# 객체 설계

객체 자동차 
속성 자동차 이름
     자동차 번호
     등록년월
행위 주행거리
     연비계산
     정비

객체 사람
속성 이름
     나이
     전화번호
행위 먹다
     자다
  

# 객체의 3가지 요소
- 상태 유지 : 상태정보 저장, 유지
- 기능 제공 : 기능 제공, Method의 제공으로 이루어짐.
- 고유식별자 제공 : 각각의 객체는 고유한 식별자를 가져야함. (ex: 주민등록증[고유함])

# 물리객체
- 실제로 사물이 존재하고, 이를 클래스로 정의

# 개념객체
- 웹 시스템에서 Service에 해당. 비즈니스 로직을 처리하는 부분.
- 비즈니스 로직에선 여러 객체를 서로 상호작용 하고, 객체가 제공하는 오퍼레이션 method를 통해 객체의 속성 변경.

# Method설계
    ▶자신의 속성에 대해 상태를 변경하는 기능을 제공
    ▶실물 객체가 가진 기능 모두 제공.
    ▶속성 선언후, 상태를 변경하는 method가 있어야 함.
    ▶각각의 Method는 서로 관련성이 있어야 함.
    ▶객체안의 Method는 객체안의 속성을 처리.
    ▶다른 객체를 전달받아 해당 다른 객체에 정의된 속성을 직접처리 X
    ▶단, Method에 실행에 필요한 값들은 매개변수의 형태로 전달함.
    ▶Getter/ Setter, CRUD, Business Logic, 생명주기 처리, 영구성 관리는 제공.
    ▶Method의 속성은 여러 속성에 해당될 수 있음.
  · 장점 : 추상화 제공, 재 사용성 향상, 유지보수의 효율성 향상
  · 무결성 : 변수는 private 선언, Method는 public 선언.
    ▶public method는 입력된 매개변수를 Validation을 한후 실행.(Getter/Setter 제외)
    ▶Validation으로 객체의 값 바꾸기, 값의 대한 유효성을 가질 수 있음.
​

# 객체지향의 4대특성
- 캡슐화 : 객체의 속성을 보호
- 상속 : 하위로 내려갈 수록 구체화.
  · 효과 : 프로그램 구조에 대한 이해도 향상, 재사용성 향상, 확장성 향상, 유지보수성 향상
- 다형성 : 하나의 개채가 여러개의 형태로 변화.
  ·오버라이딩을 통해 가능.
- 추상화 : 모델링
  · 공통적인 부분, 특정 특성을 분리해 재조합 하는 부분
  · 다형성과 상속 모두 추상화에 속함.
​
# 결합도
- 모듈간의 상호 의존 정도를 나타내는 지표.
- 낮아야 재사용 및 유지보수가 유리.

# 응집도
- 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성.
- 높아야 재사용 및 유지보수가 유리.

# 좋은 객체 지향 설계의 5가지 원칙

- SRP : 단일 책임 원칙
· 한 클래스는 하나의 책임만
· 하나의 책임이라는것은 모호(크거나 작거나 문맥과 상황에 따라 다름.)
· 중요한 기준은 변경(변경이 있을때 파급효과가 적어야 원칙을 잘따른것.)
· ex)UI변경, 객체의 생성과 사용을 분리
  
- OCP : 개방-폐쇄 원칙
· 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀있음.
· 확장을 하려면 당연히 기존 코드를 변경해야함.
· 다형성을 활용
· 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
★ 문제점
· 클라이언트서 구현 클래스를 직접 선택
· Member m = new MemoryMember(); //기본 코드
· Member m = new MemoryMember(); //변경 코드
· 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함.
· 다형성을 사용했지만 OCP원칙을 지킬 수 없다면 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요.

- LSP : 리스코프 치환 원칙
· 프로그램의 정확성을 깨기 X, 하위 타입의 인스턴스로 바꾸기 가능해야 함.
· 다형성에서 하위 클래스는 인터페이스 규약 지키기. 
· 다형성 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 사용하려면 필요.
· 단순히 컴파일에 성공하는것을 넘어서는 이야기.
· ex)자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP를 위반.

-ISP : 인터페이스 분리 원칙
· 특정 클라이언트를 위한 여러 인터페이스 > 범용 인터페이스 한개
· 자동차 인터페이스 - > 운전 인터페이스, 정비 인터페이스로 분리
· 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
· 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향 x
· -> 인터페이스가 명확해지고, 대체 가능성이 높아짐.

-DIP : 의존관계 역전 원칙
· 프로그래머는 "추상화에 의존, 구체화에 의존하면 안됨" 의존성 주입은 이 원칙을 따르는 방법중 하나.
· 구현 클래스 말고 인터페이스에 의존하라는 의미.
· 역할에 의존하게 해야 한다는 것으로 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경가능. (구현체 의존시 변경이 어려움.)
· OCP에서 설명한 Member은 인터페이스와 구현 클래스를 동시에 의존해서 DIP 위반.
​
# POJO
- 순수한 자바 객체.
- 특정 규약과 환경에 종속되지 않음.
  -> 순수 자바로 구성 가능, @Annotation기반 설정이 없음.

# POJO Framework
- Spring, Hibernate : 객체지향적인 설계를 하고 있고 POJO를 지향함.
